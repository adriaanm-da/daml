// Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package com.daml.ledger.api.auth

import java.util.concurrent.CompletionStage

import com.daml.jwt.{JwtVerifier, JwtVerifierBase}
import com.daml.ledger.api.UserManagement._
import com.daml.ledger.api.auth.AuthServiceJWT.Error
import com.daml.ledger.participant.state.index.v2.UserManagementService
import com.daml.lf.data.Ref
import io.grpc.Metadata
import org.slf4j.{Logger, LoggerFactory}
import spray.json._

import scala.collection.mutable.ListBuffer
import scala.concurrent.{ExecutionContext, Future}
import scala.jdk.FutureConverters._
import scala.util.Try

/** An AuthService that reads a JWT token from a `Authorization: Bearer` HTTP header.
 *
 * The token can either be a standard JWT token whose claims are resolved using the
 * [[userManagementService]] or a JWT token with Daml-specific claims as
 * defined in [[AuthServiceJWTPayload]]:
 */
// FIXME: ^^ review the above comment; make it more precise and ensure the reference works.
class AuthServiceJWT(verifier: JwtVerifierBase, userManagementService: UserManagementService)
                    (implicit executionContext: ExecutionContext) extends AuthService {

  protected val logger: Logger = LoggerFactory.getLogger(AuthServiceJWT.getClass)

  override def decodeMetadata(headers: Metadata): CompletionStage[ClaimSet] = {
    // FIXME
    val claimSetF = getAuthorizationHeader(headers) match {
      case None => Future.successful(ClaimSet.Unauthenticated)
      case Some(header) => parseHeader(header)
    }
    claimSetF.asJava
  }

  private[this] def userRightToClaim(r: UserRight): Claim = r match {
    case UserRight.CanActAs(p) => ClaimActAsParty(Ref.Party.assertFromString(p))
    case UserRight.CanReadAs(p) => ClaimReadAsParty(Ref.Party.assertFromString(p))
    case UserRight.ParticipantAdmin => ClaimAdmin
  }

  private[this] def getUserClaims(userId : String): Future[Option[Seq[Claim]]] =
    userManagementService.listUserRights(userId)
      .map {
        // FIXME: figure out the idiomatic way to do that
        case Left(_) => None
        case Right(x) => Some(x.view.map(userRightToClaim).toSeq)
      }

  private[this] def getAuthorizationHeader(headers: Metadata): Option[String] =
    Option.apply(headers.get(AUTHORIZATION_KEY))

  private[this] def parseHeader(header: String): Future[ClaimSet] =
    parseJWTPayload(header).fold(
      error => {
        logger.warn("Authorization error: " + error.message)
        Future.successful(ClaimSet.Unauthenticated)
      },
      token => jwtPayloadToClaims(token),
    )

  private[this] def parsePayload(jwtPayload: String): Either[Error, AuthServiceJWTPayload] = {
    import AuthServiceJWTCodec.JsonImplicits._
    Try(JsonParser(jwtPayload).convertTo[AuthServiceJWTPayload]).toEither.left.map(t =>
      Error("Could not parse JWT token: " + t.getMessage)
    )
  }

  private[this] def parseJWTPayload(header: String): Either[Error, AuthServiceJWTPayload] = {
    val BearerTokenRegex = "Bearer (.*)".r

    for {
      token <- BearerTokenRegex
        .findFirstMatchIn(header)
        .map(_.group(1))
        .toRight(Error("Authorization header does not use Bearer format"))
      decoded <- verifier
        .verify(com.daml.jwt.domain.Jwt(token))
        .toEither
        .left
        .map(e => Error("Could not verify JWT token: " + e.message))
      parsed <- parsePayload(decoded.payload)
    } yield parsed
  }

  private[this] def jwtPayloadToClaims(payload: AuthServiceJWTPayload): Future[ClaimSet.Claims] =
    if (payload.isCustomDamlToken)
      Future.successful(damlJwtPayloadToClaims(payload))
    else
      standardJwtPayloadToClaims(payload)

  private[this] def standardJwtPayloadToClaims(payload: AuthServiceJWTPayload): Future[ClaimSet.Claims] = {
    payload.applicationId match {
      case None => Future.failed(new RuntimeException("no user-id in JWT token")) // FIXME: log warning
      case Some(userId) => getUserClaims(userId).flatMap({
        case None => Future.failed(new RuntimeException(s"user-id $userId in JWT token not known")) // FIXME: log warning and correct error
        case Some(claims) =>
          Future.successful(ClaimSet.Claims(
            claims = claims,
            ledgerId = payload.ledgerId,
            participantId = payload.participantId,
            applicationId = payload.applicationId,
            expiration = payload.exp,
          ))
      })
    }
  }

  private[this] def damlJwtPayloadToClaims(payload: AuthServiceJWTPayload): ClaimSet.Claims = {
    val claims = ListBuffer[Claim]()

    // Any valid token authorizes the user to use public services
    claims.append(ClaimPublic)

    if (payload.admin)
      claims.append(ClaimAdmin)

    payload.actAs
      .foreach(party => claims.append(ClaimActAsParty(Ref.Party.assertFromString(party))))

    payload.readAs
      .foreach(party => claims.append(ClaimReadAsParty(Ref.Party.assertFromString(party))))

    ClaimSet.Claims(
      claims = claims.toList,
      ledgerId = payload.ledgerId,
      participantId = payload.participantId,
      applicationId = payload.applicationId,
      expiration = payload.exp,
    )
  }
}

object AuthServiceJWT {
  final case class Error(message: String)

  def apply(verifier: com.auth0.jwt.interfaces.JWTVerifier, userManagementService: UserManagementService)
           (implicit executionContext: ExecutionContext) =
    new AuthServiceJWT(new JwtVerifier(verifier), userManagementService)

  def apply(verifier: JwtVerifierBase, userManagementService: UserManagementService)
           (implicit executionContext: ExecutionContext) =
    new AuthServiceJWT(verifier, userManagementService)
}
